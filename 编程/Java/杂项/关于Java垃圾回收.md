#Java 
https://tobebetterjavaer.com/jvm/gc.html
---

垃圾回收(garbege collection),即gc机制,用以释放垃圾内存占用的空间,防止内存泄露.
Java中的垃圾回收设计到两个问题.
1. 如何定义垃圾
2. 如何回收垃圾

# 定义垃圾

## 引用次数算法
通过在对象中分配指定空间实现对对象被引用次数的记录,当对象不被引用时,这部分内存将会被释放.而这将在程序运行的实时,进行垃圾回收,不属于JVM stop the world类型的回收.这类回收由一个缺点,当两个变量相互引用时,则被GC回收器感知并回收.

## 可达性算法
通过GC Roots引用链作为探测起点,与GC不存在任何相连关系的,不可达的对象,将会被回收.
Java中的GC Roots
-    虚拟机栈(栈帧中的本地变量表)中引用的对象
-   方法区中类静态属性引用的对象
-   方法区中常量引用的对象
-   本地方法栈中 JNI(即一般说的 Native 方法)引用的对象

# 回收垃圾
垃圾回收要求高效,JVM并未对垃圾回收标准做出具体要求,有以下算法可供参考.
## 标记清理算法
对需要进行清理的部分进行标记,每个标记将在这个内存前,创建一个标记区.那么会产生内存碎片问题,创建对象需要连续的内存空间,而由于标记将内存分块,这部分内存将难以复用.
## 复制算法
将全部内存空间划分为两个部分,在使用时,只使用其中的一个部分,当此部分进行内存回收时,将存活对象复制到另一区域,然后彻底清除使用区域的内容以实现回收.而由于将内存划为两个大部分,所以代价过高.
## 标记整理算法
类似于标记清理算法,时对标记清理算法和复制算法的结合.仍是对需要进行清理的部分进行标记,每个标记将在这个内存前,创建一个标记区,而下一步不是进行清理,而是将所需清理内存向一侧移动,达到一定程度后,一并清理,不会产生内存碎片,代价也较低,但是由于重复更改内存,运行效率较低.
## 分代收集算法
此算法融合了以上算法思想.将对象存活周期划分为几部分,在Java中一般划分为新生代和老年代,对于有大量产生,大量清理存活率低的新生代来说,使用复制算法,对于存活率高的老年代来说,使用标记清理/整理算法.


# 内存模型与回收策略
Java内存分为新生代和老年代,新生代中分为Eden(伊甸)和Survivor(存活者)区,Survivor区分为Form和To.Java内存清理分为Minor GC和Major GC.
对于新生代来说,创造后将放入Eden区,当Eden区内存不足时,将发起MinorGC用于清理筛选内存,绝大多数对象会被销毁,而剩余对象将进入Survivor区的From块(如果不足,将直接进入老年代),而每次Minor GC将把对象从Eden和From复制到TO,再次发生Minor GC时,From与To职责互换,这样就保证了From和To中永远存在一个区域为空,不受内存碎片的影响,以解决标记清除内存碎片问题.
对于老年代来说,每次对老年代的清理为Major GC,使用标记整理算法,清理效率较低,会产生Stop the World,即STW.JVM在进行Major GC时,所有程序运行将暂停.老年代中的内存包括,1.大对象 2.长期存活对象 3.动态年龄超过平均值.










